{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ktorfit Introduction \u00b6 Ktorfit is a HTTP client/Kotlin Symbol Processor for Kotlin Multiplatform (Js, Jvm, Android, iOS, Linux) using KSP and Ktor clients inspired by Retrofit Show some and star the repo to support the project \u00b6 How to use \u00b6 First do the Setup Let\u2019s say you want to make a GET Request to https://swapi.dev/api/people/1/ Create a new Kotlin interface interface ExampleApi { @GET ( \"people/1/\" ) suspend fun getPerson (): String } Info The return type String will return the response text. When you want directly parse the response into a class you need to add a JSON,XML, etc. converter to Ktor Now we add a function that will be used to make our request. The @GET annotation will tell Ktorfit that this a GET request. The value of @GET is the relative URL path that will be appended to the base url which we set later. An interface used for Ktorfit needs to have a Http method annotation on every function. Because Ktor relies on Coroutines by default your functions need to have the suspend modifier. Alternatively you can use #Flow or Call (see below) val ktorfit = Ktorfit ( baseUrl = \"https://swapi.dev/api/\" ) val exampleApi = ktorfit . create < ExampleApi > () Next we need to create a Ktorfit object, in the constructor we set the base url. We can then use the create() function to receive an implementation of the wanted type. val response = exampleApi . getPerson () println ( response ) Now we can use exampleApi to make the request. HTTP Request \u00b6 Ktorfit supports the following the Http Method Annotations: @GET, @POST, @PUT, @DELETE, @HEAD, @OPTIONS, @PATCH Or you can set your custom method to @HTTP Query \u00b6 @GET ( \"comments\" ) suspend fun getCommentsById ( @Query ( \"postId\" ) postId : String , @QueryName queryName : String , @QueryMap headerMap : Map < String , String > ): List < Comment > You can use @Query, @QueryName or @QueryMap to set queries to your request. Example: @GET ( \"comments\" ) suspend fun getCommentsById ( @Query ( \"postId\" ) postId : String ): List < Comment > A request with getCommentsById(3) will result in the relative URL \u201ccomments?postId=3\u201d Path \u00b6 When you want to dynamically replace a part of the URL, you can use the @Path annotation. interface ExampleApi { @GET ( \"people/{peopleId}/\" ) suspend fun getPerson ( @Path ( \"peopleId\" ) id : String ): String } Just write a part of your URL path in curly braces. Then you need to annotate a parameter with @Path. The value of @Path needs to match with one of the curly braces part in your URL path. Example: On a request with getPerson(1) , {peopleId} will be replaced with the argument 1 and the relative URL will become \u201cpeople/1/\u201d Headers \u00b6 @Headers ( value = [ \"Accept: application/json\" ] ) @GET ( \"comments\" ) suspend fun requestWithHeaders ( @Header ( \"Content-Type\" ) name : String , @HeaderMap headerMap : Map < String , String > ): List < Comment > You can use @Headers, @Header or @HeaderMap to configure headers to your request. Body \u00b6 interface ExampleService { @POST ( \"upload\" ) suspend fun upload ( @Body data : String ) } @Body can be used as parameter to send data in a request body. It can only be used with Http Methods that have a request body FormData \u00b6 @POST ( \"signup\" ) @FormUrlEncoded suspend fun signup ( @Field ( \"username\" ) username : String , @Field ( \"email\" ) email : String , @Field ( \"password\" ) password : String , @Field ( \"confirmation\" ) confirmation : String ): String To send FormData you can use @Field or @FieldMap. Your function needs to be annotated with @FormUrlEncoded. Multipart \u00b6 To send Multipart data you have two options: 1) @Body \u00b6 interface ExampleService { @POST ( \"upload\" ) suspend fun upload ( @Body map : MultiPartFormDataContent ) } To upload MultiPartFormData you need to have a parameter of the type MultiPartFormDataContent that is annotated with @Body. The method needs to be annotated with @POST or @PUT val multipart = MultiPartFormDataContent ( formData { append ( \"description\" , \"Ktor logo\" ) append ( \"image\" , File ( \"ktor_logo.png\" ). readBytes (), Headers . build { append ( HttpHeaders . ContentType , \"image/png\" ) append ( HttpHeaders . ContentDisposition , \"filename=ktor_logo.png\" ) }) }) exampleApi . upload ( multipart ) Then you can use Ktor\u2019s formData Builder to create the MultiPartFormDataContent 2) @MultiPart \u00b6 @Multipart @POST ( \"upload\" ) suspend fun uploadFile ( @Part ( \"description\" ) description : String , @Part ( \"\" ) file : List < PartData > ): String You can annotate a function with @Multipart. Then you can annotate parameters with @Part val multipart = formData { append ( \"image\" , File ( \"ktor_logo.png\" ). readBytes (), Headers . build { append ( HttpHeaders . ContentType , \"image/png\" ) append ( HttpHeaders . ContentDisposition , \"filename=ktor_logo.png\" ) }) } exampleApi . upload ( \"Ktor logo\" , multipart ) All your parameters annotated with @Part wil be combined and send as MultiPartFormDataContent ResponseConverter \u00b6 The idea of a ResponseConverter is to enable directly wrapping response types into other data holder types. You can add adapters on your Ktorfit object. ktorfit . addResponseConverter ( FlowResponseConverter ()) Flow \u00b6 Ktorfit has support for Kotlin Flow. You need add the FlowResponseConverter() to your Ktorfit instance. ktorfit . addResponseConverter ( FlowResponseConverter ()) @GET ( \"comments\" ) fun getCommentsById ( @Query ( \"postId\" ) postId : String ): Flow < List < Comment >> Then you can drop the suspend modifier and wrap your return type with Flow<> Call \u00b6 ktorfit . addResponseConverter ( KtorfitResponseConverter ()) @GET ( \"people/{id}/\" ) fun getPersonById ( @Path ( \"id\" ) peopleId : Int ): Call < People > exampleApi . getPersonById ( 3 ). onExecute ( object : Callback < People > { override fun onResponse ( call : People , response : HttpResponse ) { //Do something with Response } override fun onError ( exception : Exception ) { //Do something with exception } }) You can use Call to receive the response in a Callback. Your own \u00b6 You can also add your own Converter. You just need to implement ResponseConverter class OwnResponseConverter : ResponseConverter { ... JSON \u00b6 Ktorfit doesn\u2019t parse JSON. You have to install the Json Feature to the Ktor Client that you add to Ktorfit. See here : https://ktor.io/docs/serialization-client.html val ktorClient = HttpClient () { install ( ContentNegotiation ) { json ( Json { isLenient = true ; ignoreUnknownKeys = true }) } } Streaming \u00b6 @Streaming @GET ( \"docs/response.html#streaming\" ) suspend fun getPostsStreaming (): HttpStatement To receive streaming data you need to annotate a function with @Streaming and the return type has to be HttpStatement. exampleApi . getPostsStreaming (). execute { response -> //Do something with response } For more information check Ktor docs RequestBuilder \u00b6 @GET ( \"comments\" ) suspend fun getCommentsById ( @Query ( \"postId\" ) name : String , @ReqBuilder ext : HttpRequestBuilder .() -> Unit ): List < Comment > You need to set extra configuration on your request? Add a parameter with \u201c@ReqBuilder ext: HttpRequestBuilder.() -> Unit\u201d to your function. val result = secondApi . getCommentsById ( \"3\" ) { onDownload { bytesSentTotal , contentLength -> println ( bytesSentTotal ) } } Then you can use the extension function to set additional configuration. The RequestBuilder will be applied last after everything that is set by Ktorfit Setup \u00b6 (You can also look how it\u2019s done in the examples ) For Kotlin Native Targets (iOS,Linux) you need to enable the new memory model in gradle.properties kotlin . native . binary . memoryModel = experimental KSP \u00b6 When you are not using KSP already you need to apply the plugin in your build.gradle plugins { id ( \"com.google.devtools.ksp\" ) version \"1.6.20-1.0.4\" } Next you have to add the Ktorfit KSP Plugin to the common target and every compilation target, where you want to use Ktorfit. val ktorfitVersion = \"1.0.0-beta05\" dependencies { add ( \"kspCommonMainMetadata\" , \"de.jensklingenberg.ktorfit:ktorfit-ksp: $ ktorfitVersion \" ) add ( \"ksp[NAMEOFPLATFORM]\" , \"de.jensklingenberg.ktorfit:ktorfit-ksp: $ ktorfitVersion \" ) ... } [NAMEOFPLATFORM] is the name of the compilation target. When you want to use it for the Android module it\u2019s kspAndroid , for Js it\u2019s kspJs , etc. Look here for more information https://kotlinlang.org/docs/ksp-multiplatform.html Ktorfit-lib \u00b6 Add the Ktorfit-lib to your common module. val ktorfitVersion = \"1.0.0-beta05\" sourceSets { val commonMain by getting { dependencies { implementation ( \"de.jensklingenberg.ktorfit:ktorfit-lib: $ ktorfitVersion \" ) } } Ktor \u00b6 Ktorfit is based on Ktor Clients 2.0.0. You don\u2019t need to add an extra dependency for the default clients. When you want to use Ktor plugins for things like serialization, you need to add the dependencies and they need to be compatible with 2.0.0 Contributions \u00b6 When you find unexpected behaviour please write an issue","title":"Overview"},{"location":"#introduction","text":"Ktorfit is a HTTP client/Kotlin Symbol Processor for Kotlin Multiplatform (Js, Jvm, Android, iOS, Linux) using KSP and Ktor clients inspired by Retrofit","title":"Introduction"},{"location":"#show-some-and-star-the-repo-to-support-the-project","text":"","title":"Show some  and star the repo to support the project"},{"location":"#how-to-use","text":"First do the Setup Let\u2019s say you want to make a GET Request to https://swapi.dev/api/people/1/ Create a new Kotlin interface interface ExampleApi { @GET ( \"people/1/\" ) suspend fun getPerson (): String } Info The return type String will return the response text. When you want directly parse the response into a class you need to add a JSON,XML, etc. converter to Ktor Now we add a function that will be used to make our request. The @GET annotation will tell Ktorfit that this a GET request. The value of @GET is the relative URL path that will be appended to the base url which we set later. An interface used for Ktorfit needs to have a Http method annotation on every function. Because Ktor relies on Coroutines by default your functions need to have the suspend modifier. Alternatively you can use #Flow or Call (see below) val ktorfit = Ktorfit ( baseUrl = \"https://swapi.dev/api/\" ) val exampleApi = ktorfit . create < ExampleApi > () Next we need to create a Ktorfit object, in the constructor we set the base url. We can then use the create() function to receive an implementation of the wanted type. val response = exampleApi . getPerson () println ( response ) Now we can use exampleApi to make the request.","title":"How to use"},{"location":"#http-request","text":"Ktorfit supports the following the Http Method Annotations: @GET, @POST, @PUT, @DELETE, @HEAD, @OPTIONS, @PATCH Or you can set your custom method to @HTTP","title":"HTTP Request"},{"location":"#query","text":"@GET ( \"comments\" ) suspend fun getCommentsById ( @Query ( \"postId\" ) postId : String , @QueryName queryName : String , @QueryMap headerMap : Map < String , String > ): List < Comment > You can use @Query, @QueryName or @QueryMap to set queries to your request. Example: @GET ( \"comments\" ) suspend fun getCommentsById ( @Query ( \"postId\" ) postId : String ): List < Comment > A request with getCommentsById(3) will result in the relative URL \u201ccomments?postId=3\u201d","title":"Query"},{"location":"#path","text":"When you want to dynamically replace a part of the URL, you can use the @Path annotation. interface ExampleApi { @GET ( \"people/{peopleId}/\" ) suspend fun getPerson ( @Path ( \"peopleId\" ) id : String ): String } Just write a part of your URL path in curly braces. Then you need to annotate a parameter with @Path. The value of @Path needs to match with one of the curly braces part in your URL path. Example: On a request with getPerson(1) , {peopleId} will be replaced with the argument 1 and the relative URL will become \u201cpeople/1/\u201d","title":"Path"},{"location":"#headers","text":"@Headers ( value = [ \"Accept: application/json\" ] ) @GET ( \"comments\" ) suspend fun requestWithHeaders ( @Header ( \"Content-Type\" ) name : String , @HeaderMap headerMap : Map < String , String > ): List < Comment > You can use @Headers, @Header or @HeaderMap to configure headers to your request.","title":"Headers"},{"location":"#body","text":"interface ExampleService { @POST ( \"upload\" ) suspend fun upload ( @Body data : String ) } @Body can be used as parameter to send data in a request body. It can only be used with Http Methods that have a request body","title":"Body"},{"location":"#formdata","text":"@POST ( \"signup\" ) @FormUrlEncoded suspend fun signup ( @Field ( \"username\" ) username : String , @Field ( \"email\" ) email : String , @Field ( \"password\" ) password : String , @Field ( \"confirmation\" ) confirmation : String ): String To send FormData you can use @Field or @FieldMap. Your function needs to be annotated with @FormUrlEncoded.","title":"FormData"},{"location":"#multipart","text":"To send Multipart data you have two options:","title":"Multipart"},{"location":"#1-body","text":"interface ExampleService { @POST ( \"upload\" ) suspend fun upload ( @Body map : MultiPartFormDataContent ) } To upload MultiPartFormData you need to have a parameter of the type MultiPartFormDataContent that is annotated with @Body. The method needs to be annotated with @POST or @PUT val multipart = MultiPartFormDataContent ( formData { append ( \"description\" , \"Ktor logo\" ) append ( \"image\" , File ( \"ktor_logo.png\" ). readBytes (), Headers . build { append ( HttpHeaders . ContentType , \"image/png\" ) append ( HttpHeaders . ContentDisposition , \"filename=ktor_logo.png\" ) }) }) exampleApi . upload ( multipart ) Then you can use Ktor\u2019s formData Builder to create the MultiPartFormDataContent","title":"1) @Body"},{"location":"#2-multipart","text":"@Multipart @POST ( \"upload\" ) suspend fun uploadFile ( @Part ( \"description\" ) description : String , @Part ( \"\" ) file : List < PartData > ): String You can annotate a function with @Multipart. Then you can annotate parameters with @Part val multipart = formData { append ( \"image\" , File ( \"ktor_logo.png\" ). readBytes (), Headers . build { append ( HttpHeaders . ContentType , \"image/png\" ) append ( HttpHeaders . ContentDisposition , \"filename=ktor_logo.png\" ) }) } exampleApi . upload ( \"Ktor logo\" , multipart ) All your parameters annotated with @Part wil be combined and send as MultiPartFormDataContent","title":"2) @MultiPart"},{"location":"#responseconverter","text":"The idea of a ResponseConverter is to enable directly wrapping response types into other data holder types. You can add adapters on your Ktorfit object. ktorfit . addResponseConverter ( FlowResponseConverter ())","title":"ResponseConverter"},{"location":"#flow","text":"Ktorfit has support for Kotlin Flow. You need add the FlowResponseConverter() to your Ktorfit instance. ktorfit . addResponseConverter ( FlowResponseConverter ()) @GET ( \"comments\" ) fun getCommentsById ( @Query ( \"postId\" ) postId : String ): Flow < List < Comment >> Then you can drop the suspend modifier and wrap your return type with Flow<>","title":"Flow"},{"location":"#call","text":"ktorfit . addResponseConverter ( KtorfitResponseConverter ()) @GET ( \"people/{id}/\" ) fun getPersonById ( @Path ( \"id\" ) peopleId : Int ): Call < People > exampleApi . getPersonById ( 3 ). onExecute ( object : Callback < People > { override fun onResponse ( call : People , response : HttpResponse ) { //Do something with Response } override fun onError ( exception : Exception ) { //Do something with exception } }) You can use Call to receive the response in a Callback.","title":"Call"},{"location":"#your-own","text":"You can also add your own Converter. You just need to implement ResponseConverter class OwnResponseConverter : ResponseConverter { ...","title":"Your own"},{"location":"#json","text":"Ktorfit doesn\u2019t parse JSON. You have to install the Json Feature to the Ktor Client that you add to Ktorfit. See here : https://ktor.io/docs/serialization-client.html val ktorClient = HttpClient () { install ( ContentNegotiation ) { json ( Json { isLenient = true ; ignoreUnknownKeys = true }) } }","title":"JSON"},{"location":"#streaming","text":"@Streaming @GET ( \"docs/response.html#streaming\" ) suspend fun getPostsStreaming (): HttpStatement To receive streaming data you need to annotate a function with @Streaming and the return type has to be HttpStatement. exampleApi . getPostsStreaming (). execute { response -> //Do something with response } For more information check Ktor docs","title":"Streaming"},{"location":"#requestbuilder","text":"@GET ( \"comments\" ) suspend fun getCommentsById ( @Query ( \"postId\" ) name : String , @ReqBuilder ext : HttpRequestBuilder .() -> Unit ): List < Comment > You need to set extra configuration on your request? Add a parameter with \u201c@ReqBuilder ext: HttpRequestBuilder.() -> Unit\u201d to your function. val result = secondApi . getCommentsById ( \"3\" ) { onDownload { bytesSentTotal , contentLength -> println ( bytesSentTotal ) } } Then you can use the extension function to set additional configuration. The RequestBuilder will be applied last after everything that is set by Ktorfit","title":"RequestBuilder"},{"location":"#setup","text":"(You can also look how it\u2019s done in the examples ) For Kotlin Native Targets (iOS,Linux) you need to enable the new memory model in gradle.properties kotlin . native . binary . memoryModel = experimental","title":"Setup"},{"location":"#ksp","text":"When you are not using KSP already you need to apply the plugin in your build.gradle plugins { id ( \"com.google.devtools.ksp\" ) version \"1.6.20-1.0.4\" } Next you have to add the Ktorfit KSP Plugin to the common target and every compilation target, where you want to use Ktorfit. val ktorfitVersion = \"1.0.0-beta05\" dependencies { add ( \"kspCommonMainMetadata\" , \"de.jensklingenberg.ktorfit:ktorfit-ksp: $ ktorfitVersion \" ) add ( \"ksp[NAMEOFPLATFORM]\" , \"de.jensklingenberg.ktorfit:ktorfit-ksp: $ ktorfitVersion \" ) ... } [NAMEOFPLATFORM] is the name of the compilation target. When you want to use it for the Android module it\u2019s kspAndroid , for Js it\u2019s kspJs , etc. Look here for more information https://kotlinlang.org/docs/ksp-multiplatform.html","title":"KSP"},{"location":"#ktorfit-lib","text":"Add the Ktorfit-lib to your common module. val ktorfitVersion = \"1.0.0-beta05\" sourceSets { val commonMain by getting { dependencies { implementation ( \"de.jensklingenberg.ktorfit:ktorfit-lib: $ ktorfitVersion \" ) } }","title":"Ktorfit-lib"},{"location":"#ktor","text":"Ktorfit is based on Ktor Clients 2.0.0. You don\u2019t need to add an extra dependency for the default clients. When you want to use Ktor plugins for things like serialization, you need to add the dependencies and they need to be compatible with 2.0.0","title":"Ktor"},{"location":"#contributions","text":"When you find unexpected behaviour please write an issue","title":"Contributions"},{"location":"development/","text":"Development \u00b6","title":"Development"},{"location":"development/#development","text":"","title":"Development"}]}