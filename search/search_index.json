{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"Ktorfit"},{"location":"#introduction","title":"Introduction","text":"<p>Ktorfit is a HTTP client/Kotlin Symbol Processor for Kotlin Multiplatform (Js, Jvm, Android, iOS, Linux) using KSP and Ktor clients inspired by Retrofit</p>"},{"location":"#installation","title":"Installation","text":"<p>Please see Installation</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>Please see Quick start</p>"},{"location":"#requests","title":"Requests","text":"<p>See Requests</p>"},{"location":"#suspendresponseconverter","title":"SuspendResponseConverter","text":"<p>See documentation Here</p>"},{"location":"#responseconverter","title":"ResponseConverter","text":"<p>See documentation Here</p>"},{"location":"#changelog","title":"Changelog","text":"<p>See changelog</p>"},{"location":"#contributions","title":"Contributions","text":"<p>When you find unexpected behaviour please write an issue</p>"},{"location":"CHANGELOG/","title":"1.0.0 (not released)","text":"<ul> <li>internal optimizations</li> <li>throw compile error when generated class can not be found</li> </ul>"},{"location":"CHANGELOG/#100-beta18-12-02-2023","title":"1.0.0-beta18 (12-02-2023)","text":"<p>NEW:</p> <ul> <li>You can now disable the check if the baseUrl ends with a /</li> </ul> <pre><code>Ktorfit.Builder().baseUrl(testBaseUrl, checkUrl = false).build()\n</code></pre> <p>\ud83d\udc1b Bugs fixed</p> <ul> <li>Fixed Ktorfit breaking incremental compilation #110</li> </ul> <p>\u2b06\ufe0f Deps updates</p> <ul> <li>based on Ktor 2.2.3</li> </ul>"},{"location":"CHANGELOG/#100-beta17-21-01-2023","title":"1.0.0-beta17 (21-01-2023)","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>Ktorfit now needs an additional gradle plugin. This will solve several issues with multi-module projects.</li> </ul> <p>Add this plugin: <pre><code>plugins {\nid \"de.jensklingenberg.ktorfit\" version \"1.0.0\"\n}\n</code></pre></p> <p>NEW:</p> <ul> <li>interfaces can now be internal</li> </ul> <p>\ud83d\udc1b Bugs fixed</p> <ul> <li>Ktorfit multiple module support #92</li> <li>Add support for \u2018internal\u2019 parameter type #13</li> <li>Duplicate class KtorfitExtKt found in modules moduleA and moduleB #86</li> <li>Android overload resolution ambiguity #64</li> <li>Form data is double encoded #95</li> </ul> <p>\u2b06\ufe0f Deps updates</p> <ul> <li>based on Ktor 2.2.2</li> <li>Kotlin 1.8.0</li> <li>KSP 1.8.0-1.0.8</li> <li>update Android TargetSdk to 33</li> </ul>"},{"location":"CHANGELOG/#100-beta16-13-11-2022","title":"1.0.0-beta16 (13-11-2022)","text":"<p>NEW: - Field parameters can now be nullable, null values will be ignored in requests - Add option to turn of error checking</p> <p>ksp {   arg(\u201cKtorfit_Errors\u201d, \u201c1\u201d)   }</p> <p>You can set it in your build.gradle.kts file, </p> <p>0: Turn off all Ktorfit related error checking</p> <p>1: Check for errors</p> <p>2: Turn errors into warnings</p> <ul> <li>Added RequestConverter support #84</li> </ul> <p>\u2b06\ufe0f Deps updates</p> <ul> <li>based on Ktor 2.1.3</li> <li>Kotlin 1.7.21</li> <li>KSP 1.0.8</li> <li>update Android TargetSdk to 33</li> </ul> <p>\ud83d\udc1b Bugs fixed</p> <ul> <li>FlowResponseConverter #81</li> </ul>"},{"location":"CHANGELOG/#whats-changed","title":"What\u2019s Changed","text":"<ul> <li>build(deps): bump logback-classic from 1.4.0 to 1.4.3 by @dependabot in https://github.com/Foso/Ktorfit/pull/74</li> <li>Foso/revert converters changes by @Foso in https://github.com/Foso/Ktorfit/pull/76</li> <li>67 add nullable field parameters support by @Foso in https://github.com/Foso/Ktorfit/pull/80</li> <li>fix: FlowResponseConverter by @Foso in https://github.com/Foso/Ktorfit/pull/81</li> <li>Added RequestConverter support by @DATL4G in https://github.com/Foso/Ktorfit/pull/84</li> <li>feat: add option to turn off error checking #77 by @Foso in https://github.com/Foso/Ktorfit/pull/88</li> </ul> <p>Full Changelog: https://github.com/Foso/Ktorfit/compare/v1.0.0-beta15...v1.0.0-beta16</p>"},{"location":"CHANGELOG/#100-beta15-05-10-2022","title":"1.0.0-beta15 (05-10-2022)","text":"<p>\u2b06\ufe0f Deps updates</p> <ul> <li>based on Ktor 2.1.2</li> </ul> <p>\ud83d\udc1b Bugs fixed</p> <ul> <li>kotlinx.coroutines.JobCancellationException: Parent job is Completed #70</li> </ul> <p>\ud83d\udca5 Breaking changes</p> <ul> <li>reverted the api of converters to the state of beta13, see #71 </li> <li>when you are updating from beta13, this is the only change to converters:   returnTypeName is replaced through typeData, you can use typeData.qualifiedName to get the same value as returnTypeName</li> </ul>"},{"location":"CHANGELOG/#100-beta14-24-09-2022","title":"1.0.0-beta14 (24-09-2022)","text":"<p>NEW: - Query parameters can now be nullable, null values will be ignored in requests - Function return types can now be nullable</p> <p>FIX: - Url annotation not resolved correctly #65</p> <p>BREAKING CHANGES: - Changed naming of Converters:</p> <ul> <li>SuspendResponseConverter:<ul> <li>is now called RequestConverter</li> <li>the wrapSuspendResponse is now called convertRequest.</li> <li>returnTypeName is replaced through typeData, you can use typeData.qualifiedName to get the same value as returnTypeName   RequestConverter need to be added with the requestConverter() on your Ktorfit object.</li> <li>https://foso.github.io/Ktorfit/requestconverter/</li> </ul> </li> <li>ResponseConverters:<ul> <li>returnTypeName is replaced through typeData, you can use typeData.qualifiedName to get the same value as returnTypeName   https://foso.github.io/Ktorfit/responseconverter/</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#100-beta13-10-09-2022","title":"1.0.0-beta13 (10-09-2022)","text":"<ul> <li>KtorfitCallResponseConverter and KtorfitSuspendCallResponseConverter are now combined in KtorfitCallResponseConverter</li> <li>based on Ktor 2.1.1</li> </ul> <p>Fixed: - Url annotation not resolved correctly #52</p>"},{"location":"CHANGELOG/#100-beta12-31-08-2022","title":"1.0.0-beta12 (31-08-2022)","text":""},{"location":"CHANGELOG/#breaking-changes","title":"Breaking Changes:","text":"<p>wrapResponse from SuspendResponseConverter got renamed to wrapSuspendResponse. This add the possibility to have ResponseConverter and SuspendResponseConverter implemented in the same class.</p>"},{"location":"CHANGELOG/#changes","title":"Changes:","text":"<ul> <li>throw compiler time error when you use @Path without the corresponding value inside the relative url path</li> <li>every generated implementation class of an interface that Ktorfit generates will now contain a \u201ccreate\u201d ext function that can be used instead of the generic create() function e.g. Let\u2019s say you have a interface GithubService, then you can create an instance like this:</li> </ul> <p><pre><code>val ktorfit = ktorfit {\nbaseUrl(\"http://example.com/\")\n}.create&lt;GithubService&gt;()\n</code></pre> or this</p> <pre><code>val ktorfit = ktorfit {\nbaseUrl(\"http://example.com/\")\n}.createGithubService()\n</code></pre> <p>By default, IntelliJ/Android Studio can\u2019t find the generated code, you need to add the KSP generated folder to the sourcesets  like this: (See more here: https://kotlinlang.org/docs/ksp-quickstart.html#make-ide-aware-of-generated-code)</p> <pre><code>kotlin.srcDir(\"build/generated/ksp/jvm/jvmMain/\")\n</code></pre>"},{"location":"CHANGELOG/#100-beta11-21-08-2022","title":"1.0.0-beta11 (21-08-2022)","text":"<ul> <li>you can now use ResponseConverter in combination with suspend functions. Implement the SuspendResponseConverter</li> <li>KtorfitCallResponseConverter and FlowResponseConverter moved to de.jensklingenberg.ktorfit.converter.builtin</li> </ul>"},{"location":"CHANGELOG/#100-beta10-18-08-2022","title":"1.0.0-beta10 (18-08-2022)","text":"<ul> <li>based on Ktor 2.0.2</li> <li>added windows target #26</li> <li>@PATCH, @POST, @PUT now have a default value #22</li> <li>Ktorfit now uses a builder pattern for setup  e.g. change this:   <code>kotlin  Ktorfit(\"https://example.com/\", HttpClient {})</code></li> </ul> <p>to this: </p> <pre><code>Ktorfit.Builder()\n.baseUrl(\"https://example.com/\")\n.httpClient(HttpClient {})\n.build()\n</code></pre> <ul> <li></li> </ul>"},{"location":"CHANGELOG/#breaking-changes_1","title":"Breaking Changes:","text":"<p>@Headers now requires a vararg of String instead of an Array e.g. you need to change from:</p> <pre><code>@Headers(\n[\"Authorization: token ghp_abcdefgh\",\n\"Content-Type: application/json\"]\n)\n</code></pre> <p>to this: <pre><code>@Headers(\n\"Authorization: token ghp_abcdefgh\",\n\"Content-Type: application/json\"\n)\n</code></pre></p>"},{"location":"CHANGELOG/#100-beta09","title":"1.0.0-beta09","text":""},{"location":"CHANGELOG/#15-fix-encoding-of-query-parameters","title":"15 fix encoding of query parameters","text":""},{"location":"CHANGELOG/#100-beta08","title":"1.0.0-beta08","text":"<ul> <li>fix issue with Koin Annotations</li> </ul>"},{"location":"CHANGELOG/#100-beta07","title":"1.0.0-beta07","text":"<ul> <li>fix issue with FormUrlEncoded</li> <li>based on Ktor 2.0.2</li> </ul>"},{"location":"CHANGELOG/#100-beta06","title":"1.0.0-beta06","text":"<ul> <li>fix issue with KSP 1.0.5 #19</li> </ul>"},{"location":"CHANGELOG/#100-beta05","title":"1.0.0-beta05","text":"<ul> <li>fixed: Custom Http Method with @Body is now possible #6</li> <li>based on Ktor 2.0.1</li> <li>cleanup example project @mattrob33</li> </ul>"},{"location":"CHANGELOG/#100-beta04","title":"1.0.0-beta04","text":"<p>initial release</p>"},{"location":"architecture/","title":"How Ktorfit works under the hood","text":"<p>Ktorfit consists of three main components KSP-Plugin, Compiler plugin and the Ktorfit lib</p>"},{"location":"architecture/#ksp-plugin","title":"KSP-Plugin","text":"<p>This will generate the code for the implementation of the interfaces</p>"},{"location":"architecture/#compiler-plugin","title":"Compiler plugin","text":"<p>This transforms the create() function from the Ktorfit lib</p>"},{"location":"architecture/#ktorfit-lib","title":"Ktorfit lib","text":"<p>A wrapper around Ktor to simplify code generation</p>"},{"location":"architecture/#example","title":"Example","text":"<p><pre><code>package com.example\n\nimport com.example.model.People\nimport de.jensklingenberg.ktorfit.http.GET\n\ninterface ExampleApi  {\n@GET(\"/test\")\nsuspend fun exampleGet(): People\n}\n</code></pre> Let`s say we have a interface like this.</p> <p>At compile time Ktorfit/KSP checks for all functions that are annotated with Ktorfit annotations like @GET.</p> <p>Then it looks at the parent interfaces of that functions and generates, the source code of a Kotlin class that implements the interface. The classes are named like the interfaces but with an underscore at the beginning and \u201cImpl\u201d at the end, and they have the same package as the interfaces. In this case a class named _ExampleApiImpl will be generated. The class will also implement KtorfitService. The setClient() function will be used to add the http client at runtime.</p> <pre><code>@OptIn(InternalKtorfitApi::class)\npublic class _ExampleApiImpl : ExampleApi, KtorfitService {\nprivate lateinit var client: KtorfitClient\n\npublic override suspend fun exampleGet(): People {\nval requestData = RequestData(method=\"GET\",\nrelativeUrl=\"/test\",\nreturnTypeData=TypeData(\"com.example.model.People\"))\n\nreturn client.suspendRequest&lt;People, People&gt;(requestData)!!\n}\n\npublic override fun setClient(client: KtorfitClient): Unit {\nthis.client = client\n}\n}\n\n@OptIn(InternalKtorfitApi::class)\npublic fun Ktorfit.createExampleApi(): ExampleApi = _ExampleApiImpl().also{\nit.setClient(KtorfitClient(this)) }\n</code></pre> <p>The next part is the compiler plugin which is added by the gradle plugin. It looks for the every usage of the create function from the Ktorfit-lib and adds an object of the  wanted implementation class as an argument. Because of the naming convention of the generated classes we can deduce the name of the class from the name of type parameter.</p> <pre><code>val api = jvmKtorfit.create&lt;ExampleApi&gt;()\n</code></pre> <p>will be transformed to: </p> <pre><code>val api = jvmKtorfit.create&lt;ExampleApi&gt;(_ExampleApiImpl())\n</code></pre> <p>When the create() function is used, the object is cast to a KtorfitService and the client will be added. Then it is cast to requested type &lt; T &gt;</p> <pre><code>fun &lt;T&gt; create(ktorfitService: KtorfitService = DefaultKtorfitService()): T {\nif (ktorfitService is DefaultKtorfitService) {\nthrow IllegalArgumentException(\"You need to enable the Ktorfit Gradle Plugin\")\n}\nktorfitService.setClient(KtorfitClient(this))\nreturn ktorfitService as T\n}\n</code></pre>"},{"location":"configuration/","title":"Compile errors","text":"<p>By default, Ktorfit will throw compile error when it finds conditions under which it can\u2019t ensure that it will work correct. You can set an KSP argument to change this:</p> <pre><code>ksp {\narg(\"Ktorfit_Errors\", \"1\")\n}\n</code></pre> <p>You can set it in your build.gradle.kts file,</p> <p>0: Turn off all Ktorfit related error checking</p> <p>1: Check for errors</p> <p>2: Turn errors into warnings</p>"},{"location":"development/","title":"Development","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#setup","title":"Setup","text":"<p>(You can also look how it\u2019s done in the examples)</p>"},{"location":"installation/#gradle-plugins","title":"Gradle Plugins","text":"<p>You need to add KSP and the Ktorfit Gradle plugin <pre><code>plugins {\nid(\"com.google.devtools.ksp\") version \"CURRENT_KSP_VERSION\"\nid(\"de.jensklingenberg.ktorfit\") version \"1.0.0\"\n}\n</code></pre></p> <p>Next you have to add the Ktorfit KSP Plugin to the common target and every compilation target, where you want to use Ktorfit.</p> <pre><code>val ktorfitVersion = \"LATEST_KTORFIT_VERSION\"\n\ndependencies {\nadd(\"kspCommonMainMetadata\", \"de.jensklingenberg.ktorfit:ktorfit-ksp:$ktorfitVersion\")\nadd(\"ksp[NAMEOFPLATFORM]\",\"de.jensklingenberg.ktorfit:ktorfit-ksp:$ktorfitVersion\")\n...\n}\n</code></pre> <p>[NAMEOFPLATFORM] is the name of the compilation target. When you want to use it for the Android module it\u2019s kspAndroid, for Js it\u2019s kspJs, etc. Look here for more information https://kotlinlang.org/docs/ksp-multiplatform.html</p>"},{"location":"installation/#ktorfit-lib","title":"Ktorfit-lib","text":"<p>Add the Ktorfit-lib to your common module. <pre><code>val ktorfitVersion = \"LATEST_KTORFIT_VERSION\"\n\nsourceSets {\nval commonMain by getting{\ndependencies{\nimplementation(\"de.jensklingenberg.ktorfit:ktorfit-lib:$ktorfitVersion\")\n}\n}\n</code></pre></p>"},{"location":"installation/#ktor","title":"Ktor","text":"<p>Ktorfit is based on Ktor Clients 2.2.3. You don\u2019t need to add an extra dependency for the default clients. When you want to use Ktor plugins for things like serialization, you need to add the dependencies and they need to be compatible with 2.2.3</p>"},{"location":"quick-start/","title":"Quick start","text":"<p>First do the Installation</p> <p>Let\u2019s say you want to make a GET Request to https://swapi.dev/api/people/1/</p> <p>Create a new Kotlin interface</p> <pre><code>interface ExampleApi {\n@GET(\"people/1/\")\nsuspend fun getPerson(): String\n}\n</code></pre> <p>Info</p> <p>The return type String will return the response text. When you want directly parse the response into a class you need to add a JSON,XML, etc. converter to Ktor</p> <p>Now we add a function that will be used to make our request. The @GET annotation will tell Ktorfit that this a GET request. The value of @GET is the relative URL path that will be appended to the base url which we set later.</p> <p>An interface used for Ktorfit needs to have a HTTP method annotation on every function. Because Ktor relies on Coroutines by default your functions need to have the suspend modifier. Alternatively you can use #Flow or Call</p> <pre><code>val ktorfit = Ktorfit.Builder().baseUrl(\"https://swapi.dev/api/\").build()\nval exampleApi = ktorfit.create&lt;ExampleApi&gt;()\n</code></pre> <p>Next we need to create a Ktorfit object, in the constructor we set the base url. We can then use the create() function to receive an implementation of the wanted type.</p> <pre><code>val response = exampleApi.getPerson()\nprintln(response)\n</code></pre> <p>Now we can use exampleApi to make the request.</p>"},{"location":"requests/","title":"Requests","text":""},{"location":"requests/#http-request","title":"HTTP Request","text":"<p>Ktorfit supports the following the HTTP method annotations:</p> <ul> <li>@GET</li> <li>@POST</li> <li>@PUT</li> <li>@DELETE</li> <li>@HEAD</li> <li>@OPTIONS</li> <li>@PATCH</li> </ul> <p>Or you can set your custom method to @HTTP</p> <pre><code>@GET(\"posts\")\nfun getPosts(): List&lt;Post&gt;\n</code></pre> <p>The value of the HTTP annotation will be appended to the baseUrl that you set in the Ktorfit builder. If the value contains a url that starts with http or https, this url will be used for the request instead of the baseUrl.</p> <pre><code>@GET(\"https://example.com/posts\")\nfun getPosts(): List&lt;Post&gt;\n</code></pre> <p>The value can only be empty when you also use @Url</p>"},{"location":"requests/#url","title":"Url","text":"<p>Can be used to set a URL dynamically as a function parameter. <pre><code>@GET(\"\")\nsuspend fun getPosts(@Url url: String): List&lt;Post&gt;\n</code></pre></p>"},{"location":"requests/#query","title":"Query","text":"<pre><code>@GET(\"comments\")\nsuspend fun getCommentsById(\n@Query(\"postId\") postId: String,\n@QueryName queryName: String,\n@QueryMap headerMap : Map&lt;String,String&gt;\n): List&lt;Comment&gt;\n</code></pre> <p>You can use @Query, @QueryName or @QueryMap to set queries to your request.</p> <p>Example: <pre><code>@GET(\"comments\")\nsuspend fun getCommentsById(@Query(\"postId\") postId: String): List&lt;Comment&gt;\n</code></pre></p> <p>A request with getCommentsById(3) will result in the relative URL \u201ccomments?postId=3\u201d</p>"},{"location":"requests/#path","title":"Path","text":"<p>When you want to dynamically replace a part of the URL, you can use the @Path annotation. <pre><code>interface ExampleApi {\n@GET(\"people/{peopleId}/\")\nsuspend fun getPerson(@Path(\"peopleId\") id: String): String\n}\n</code></pre> Just write a part of your URL path in curly braces. Then you need to annotate a parameter with @Path. The value of @Path needs to match with one of the curly braces part in your URL path.</p> <p>Example:</p> <p>On a request with getPerson(1) , {peopleId} will be replaced with the argument 1 and the relative URL will become \u201cpeople/1/\u201d</p>"},{"location":"requests/#headers","title":"Headers","text":"<pre><code>@Headers(\"Accept: application/json\")\n@GET(\"comments\")\nsuspend fun requestWithHeaders(\n@Header(\"Content-Type\") name: String,\n@HeaderMap headerMap : Map&lt;String,String&gt;\n): List&lt;Comment&gt;\n</code></pre> <p>You can use @Headers, @Header or @HeaderMap to configure headers to your request.</p>"},{"location":"requests/#body","title":"Body","text":"<pre><code>interface ExampleService {\n@POST(\"upload\")\nsuspend fun upload(@Body data: String)\n}\n</code></pre> <p>@Body can be used as parameter to send data in a request body. It can only be used with Http Methods that have a request body</p>"},{"location":"requests/#formdata","title":"FormData","text":"<pre><code>@POST(\"signup\")\n@FormUrlEncoded\nsuspend fun signup(\n@Field(\"username\") username: String, @Field(\"email\") email: String,\n@Field(\"password\") password: String, @Field(\"confirmation\") confirmation: String\n): String\n</code></pre> <p>To send FormData you can use @Field or @FieldMap. Your function needs to be annotated with @FormUrlEncoded.</p>"},{"location":"requests/#multipart","title":"Multipart","text":"<p>To send Multipart data you have two options:</p>"},{"location":"requests/#1-body","title":"1) @Body","text":"<pre><code>interface ExampleService {\n@POST(\"upload\")\nsuspend fun upload(@Body map: MultiPartFormDataContent)\n}\n</code></pre> <p>To upload MultiPartFormData you need to have a parameter of the type MultiPartFormDataContent that is annotated with @Body. The method needs to be annotated with @POST or @PUT</p> <pre><code>val multipart = MultiPartFormDataContent(formData {\nappend(\"description\", \"Ktor logo\")\nappend(\"image\", File(\"ktor_logo.png\").readBytes(), Headers.build {\nappend(HttpHeaders.ContentType, \"image/png\")\nappend(HttpHeaders.ContentDisposition, \"filename=ktor_logo.png\")\n})\n})\n\nexampleApi.upload(multipart)\n</code></pre> <p>Then you can use Ktor\u2019s formData Builder to create the MultiPartFormDataContent</p>"},{"location":"requests/#2-multipart","title":"2) @MultiPart","text":"<pre><code>@Multipart\n@POST(\"upload\")\nsuspend fun uploadFile(@Part(\"description\") description: String, @Part(\"\") file: List&lt;PartData&gt;): String\n</code></pre> <p>You can annotate a function with @Multipart. Then you can annotate parameters with @Part</p> <pre><code>val multipart = formData {\nappend(\"image\", File(\"ktor_logo.png\").readBytes(), Headers.build {\nappend(HttpHeaders.ContentType, \"image/png\")\nappend(HttpHeaders.ContentDisposition, \"filename=ktor_logo.png\")\n})\n}\n\nexampleApi.upload(\"Ktor logo\",multipart)\n</code></pre> <p>All your parameters annotated with @Part wil be combined and send as MultiPartFormDataContent</p>"},{"location":"requests/#json","title":"JSON","text":"<p>Ktorfit doesn\u2019t parse JSON. You have to install the Json Feature to the Ktor Client that you add to Ktorfit. See here : https://ktor.io/docs/serialization-client.html</p> <pre><code>val ktorClient = HttpClient() {\ninstall(ContentNegotiation) {\njson(Json { isLenient = true; ignoreUnknownKeys = true })\n}\n}\n</code></pre>"},{"location":"requests/#streaming","title":"Streaming","text":"<pre><code>@Streaming\n@GET(\"docs/response.html#streaming\")\nsuspend fun getPostsStreaming(): HttpStatement\n</code></pre> <p>To receive streaming data you need to annotate a function with @Streaming and the return type has to be HttpStatement.</p> <pre><code>exampleApi.getPostsStreaming().execute { response -&gt;\n//Do something with response\n}\n</code></pre> <p>For more information check Ktor docs</p>"},{"location":"requests/#requestbuilder","title":"RequestBuilder","text":"<pre><code>@GET(\"comments\")\nsuspend fun getCommentsById(\n@Query(\"postId\") name: String,\n@ReqBuilder ext: HttpRequestBuilder.() -&gt; Unit\n): List&lt;Comment&gt;\n</code></pre> <p>You need to set extra configuration on your request? Add a parameter with \u201c@ReqBuilder ext: HttpRequestBuilder.() -&gt; Unit\u201d to your function. <pre><code>val result = secondApi.getCommentsById(\"3\") {\nonDownload { bytesSentTotal, contentLength -&gt;\nprintln(bytesSentTotal)\n}\n}\n</code></pre></p> <p>Then you can use the extension function to set additional configuration. The RequestBuilder will be applied last after everything that is set by Ktorfit</p>"},{"location":"responseconverter/","title":"ResponseConverter","text":"<p>Let`s say you have a function that requests a list of comments</p> <pre><code>@GET(\"posts/{postId}/comments\")\nsuspend fun getCommentsByPostId(@Path(\"postId\") postId: Int): List&lt;Comment&gt;\n</code></pre> <p>But now you want to directly wrap your comment list in your data holder class e.g. \u201cMyOwnResponse\u201d</p> <pre><code>sealed class MyOwnResponse&lt;T&gt; {\ndata class Success&lt;T&gt;(val data: T) : Response&lt;T&gt;()\nclass Error(val ex:Throwable) : Response&lt;Nothing&gt;()\n\ncompanion object {\nfun &lt;T&gt; success(data: T) = Success(data)\nfun error(ex: Throwable) = Error(ex)\n}\n}\n</code></pre> <p>To enable that, you have to implement a ResponseConverter. This class will be used to wrap the Ktor response inside your wrapper class.</p> <pre><code>class MyOwnResponseConverter : ResponseConverter {\n\noverride suspend fun &lt;RequestType&gt; wrapResponse(\ntypeData: TypeData,\nrequestFunction: suspend () -&gt; Pair&lt;TypeInfo, HttpResponse&gt;,\nktorfit: Ktorfit\n): Any {\nreturn try {\nval (info, response) = requestFunction()\nMyOwnResponse.success&lt;Any&gt;(response.body(info))\n} catch (ex: Throwable) {\nMyOwnResponse.error(ex)\n}\n}\n\noverride fun supportedType(typeData: TypeData, isSuspend: Boolean): Boolean {\nreturn typeData.qualifiedName == \"com.example.model.MyOwnResponse\"\n}\n}\n</code></pre> <p>You can then add the ResponseConverter on your Ktorfit object.</p> <pre><code>ktorfit.responseConverter(MyOwnResponseConverter())\n</code></pre> <p>Now add MyOwnResponse to your function <pre><code>@GET(\"posts/{postId}/comments\")\nsuspend fun getCommentsByPostId(@Path(\"postId\") postId: Int): MyOwnResponse&lt;List&lt;Comment&gt;&gt;\n</code></pre></p>"},{"location":"suspendresponseconverter/","title":"SuspendResponseConverter","text":"<p>Because Ktor relies on Coroutines by default your functions need to have the suspend modifier.</p> <p>To change this, you need to use a SuspendResponseConverter, you add your own or use Flow or Call</p> <p>You can add RequestConverter on your Ktorfit object.</p> <pre><code>ktorfit.responseConverter(FlowResponseConverter())\n</code></pre>"},{"location":"suspendresponseconverter/#flow","title":"Flow","text":"<p>Ktorfit has support for Kotlin Flow. You need add the FlowResponseConverter() to your Ktorfit instance.</p> <pre><code>ktorfit.responseConverter(FlowResponseConverter())\n</code></pre> <pre><code>@GET(\"comments\")\nfun getCommentsById(@Query(\"postId\") postId: String): Flow&lt;List&lt;Comment&gt;&gt;\n</code></pre> <p>Then you can drop the suspend modifier and wrap your return type with Flow&lt;&gt;</p>"},{"location":"suspendresponseconverter/#call","title":"Call","text":"<p><pre><code>ktorfit.responseConverter(CallResponseConverter())\n</code></pre> <pre><code>@GET(\"people/{id}/\")\nfun getPersonById(@Path(\"id\") peopleId: Int): Call&lt;People&gt;\n</code></pre></p> <pre><code>exampleApi.getPersonById(3).onExecute(object : Callback&lt;People&gt;{\noverride fun onResponse(call: People, response: HttpResponse) {\n//Do something with Response\n}\n\noverride fun onError(exception: Exception) {\n//Do something with exception\n}\n})\n</code></pre> <p>You can use Call to receive the response in a Callback."},{"location":"suspendresponseconverter/#your-own","title":"Your own","text":"<p>You can also add your own Converter. You just need to implement RequestConverter. Inside the converter you need to handle the conversion from suspend to your async code.</p> <pre><code>class MyOwnResponseConverter : SuspendResponseConverter {\n...\n</code></pre>"}]}