{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"Ktorfit"},{"location":"#introduction","title":"Introduction","text":"<p>Ktorfit is a HTTP client/Kotlin Symbol Processor for Kotlin Multiplatform (Js, Jvm, Android, iOS, Linux) using KSP and Ktor clients inspired by Retrofit</p>"},{"location":"#show-some-and-star-the-repo-to-support-the-project","title":"Show some  and star the repo to support the project","text":""},{"location":"#how-to-use","title":"How to use","text":"<p>First do the Setup</p> <p>Let\u2019s say you want to make a GET Request to https://swapi.dev/api/people/1/</p> <p>Create a new Kotlin interface</p> <pre><code>interface ExampleApi {\n@GET(\"people/1/\")\nsuspend fun getPerson(): String\n}\n</code></pre> <p>Info</p> <p>The return type String will return the response text. When you want directly parse the response into a class you need to add a JSON,XML, etc. converter to Ktor</p> <p>Now we add a function that will be used to make our request. The @GET annotation will tell Ktorfit that this a GET request. The value of @GET is the relative URL path that will be appended to the base url which we set later.</p> <p>An interface used for Ktorfit needs to have a Http method annotation on every function. Because Ktor relies on Coroutines by default your functions need to have the suspend modifier. Alternatively you can use #Flow or Call</p> <pre><code>val ktorfit = Ktorfit.Builder().baseUrl(\"https://swapi.dev/api/\").build()\nval exampleApi = ktorfit.create&lt;ExampleApi&gt;()\n</code></pre> <p>Next we need to create a Ktorfit object, in the constructor we set the base url. We can then use the create() function to receive an implementation of the wanted type.</p> <pre><code>val response = exampleApi.getPerson()\nprintln(response)\n</code></pre> <p>Now we can use exampleApi to make the request.</p>"},{"location":"#http-request","title":"HTTP Request","text":"<p>Ktorfit supports the following the Http Method Annotations: @GET, @POST, @PUT, @DELETE, @HEAD, @OPTIONS, @PATCH</p> <p>Or you can set your custom method to @HTTP</p>"},{"location":"#query","title":"Query","text":"<pre><code>@GET(\"comments\")\nsuspend fun getCommentsById(\n@Query(\"postId\") postId: String,\n@QueryName queryName: String,\n@QueryMap headerMap : Map&lt;String,String&gt;\n): List&lt;Comment&gt;\n</code></pre> <p>You can use @Query, @QueryName or @QueryMap to set queries to your request.</p> <p>Example: <pre><code>@GET(\"comments\")\nsuspend fun getCommentsById(@Query(\"postId\") postId: String): List&lt;Comment&gt;\n</code></pre></p> <p>A request with getCommentsById(3) will result in the relative URL \u201ccomments?postId=3\u201d</p>"},{"location":"#path","title":"Path","text":"<p>When you want to dynamically replace a part of the URL, you can use the @Path annotation. <pre><code>interface ExampleApi {\n@GET(\"people/{peopleId}/\")\nsuspend fun getPerson(@Path(\"peopleId\") id: String): String\n}\n</code></pre> Just write a part of your URL path in curly braces. Then you need to annotate a parameter with @Path. The value of @Path needs to match with one of the curly braces part in your URL path.</p> <p>Example:</p> <p>On a request with getPerson(1) , {peopleId} will be replaced with the argument 1 and the relative URL will become \u201cpeople/1/\u201d</p>"},{"location":"#headers","title":"Headers","text":"<pre><code>@Headers(\"Accept: application/json\")\n@GET(\"comments\")\nsuspend fun requestWithHeaders(\n@Header(\"Content-Type\") name: String,\n@HeaderMap headerMap : Map&lt;String,String&gt;\n): List&lt;Comment&gt;\n</code></pre> <p>You can use @Headers, @Header or @HeaderMap to configure headers to your request.</p>"},{"location":"#body","title":"Body","text":"<pre><code>interface ExampleService {\n@POST(\"upload\")\nsuspend fun upload(@Body data: String)\n}\n</code></pre> <p>@Body can be used as parameter to send data in a request body. It can only be used with Http Methods that have a request body</p>"},{"location":"#formdata","title":"FormData","text":"<pre><code>@POST(\"signup\")\n@FormUrlEncoded\nsuspend fun signup(\n@Field(\"username\") username: String, @Field(\"email\") email: String,\n@Field(\"password\") password: String, @Field(\"confirmation\") confirmation: String\n): String\n</code></pre> <p>To send FormData you can use @Field or @FieldMap. Your function needs to be annotated with @FormUrlEncoded. </p>"},{"location":"#multipart","title":"Multipart","text":"<p>To send Multipart data you have two options: </p>"},{"location":"#1-body","title":"1) @Body","text":"<pre><code>interface ExampleService {\n@POST(\"upload\")\nsuspend fun upload(@Body map: MultiPartFormDataContent)\n}\n</code></pre> <p>To upload MultiPartFormData you need to have a parameter of the type MultiPartFormDataContent that is annotated with @Body. The method needs to be annotated with @POST or @PUT</p> <pre><code>val multipart = MultiPartFormDataContent(formData {\nappend(\"description\", \"Ktor logo\")\nappend(\"image\", File(\"ktor_logo.png\").readBytes(), Headers.build {\nappend(HttpHeaders.ContentType, \"image/png\")\nappend(HttpHeaders.ContentDisposition, \"filename=ktor_logo.png\")\n})\n})\n\nexampleApi.upload(multipart)\n</code></pre> <p>Then you can use Ktor\u2019s formData Builder to create the MultiPartFormDataContent</p>"},{"location":"#2-multipart","title":"2) @MultiPart","text":"<pre><code>@Multipart\n@POST(\"upload\")\nsuspend fun uploadFile(@Part(\"description\") description: String, @Part(\"\") file: List&lt;PartData&gt;): String\n</code></pre> <p>You can annotate a function with @Multipart. Then you can annotate parameters with @Part </p> <pre><code>val multipart = formData {\nappend(\"image\", File(\"ktor_logo.png\").readBytes(), Headers.build {\nappend(HttpHeaders.ContentType, \"image/png\")\nappend(HttpHeaders.ContentDisposition, \"filename=ktor_logo.png\")\n})\n}\n\nexampleApi.upload(\"Ktor logo\",multipart)\n</code></pre> <p>All your parameters annotated with @Part wil be combined and send as MultiPartFormDataContent</p>"},{"location":"#suspendresponseconverter","title":"SuspendResponseConverter","text":"<p>See documentation Here</p>"},{"location":"#responseconverter","title":"ResponseConverter","text":"<p>See documentation Here</p>"},{"location":"#json","title":"JSON","text":"<p>Ktorfit doesn\u2019t parse JSON. You have to install the Json Feature to the Ktor Client that you add to Ktorfit. See here : https://ktor.io/docs/serialization-client.html</p> <pre><code>val ktorClient = HttpClient() {\ninstall(ContentNegotiation) {\njson(Json { isLenient = true; ignoreUnknownKeys = true })\n}\n}\n</code></pre>"},{"location":"#streaming","title":"Streaming","text":"<pre><code>@Streaming\n@GET(\"docs/response.html#streaming\")\nsuspend fun getPostsStreaming(): HttpStatement\n</code></pre> <p>To receive streaming data you need to annotate a function with @Streaming and the return type has to be HttpStatement.</p> <pre><code>exampleApi.getPostsStreaming().execute { response -&gt;\n//Do something with response\n}\n</code></pre> <p>For more information check Ktor docs</p>"},{"location":"#requestbuilder","title":"RequestBuilder","text":"<pre><code>@GET(\"comments\")\nsuspend fun getCommentsById(\n@Query(\"postId\") name: String,\n@ReqBuilder ext: HttpRequestBuilder.() -&gt; Unit\n): List&lt;Comment&gt;\n</code></pre> <p>You need to set extra configuration on your request? Add a parameter with \u201c@ReqBuilder ext: HttpRequestBuilder.() -&gt; Unit\u201d to your function. <pre><code>val result = secondApi.getCommentsById(\"3\") {\nonDownload { bytesSentTotal, contentLength -&gt;\nprintln(bytesSentTotal)\n}\n}\n</code></pre></p> <p>Then you can use the extension function to set additional configuration. The RequestBuilder will be applied last after everything that is set by Ktorfit</p>"},{"location":"#setup","title":"Setup","text":"<p>(You can also look how it\u2019s done in the examples)</p>"},{"location":"#gradle-plugins","title":"Gradle Plugins","text":"<p>You need to add KSP and the Ktorfit Gradle plugin <pre><code>plugins {\nid(\"com.google.devtools.ksp\") version \"1.7.20-1.0.8\"\nid(\"de.jensklingenberg.ktorfit\") version \"1.0.0\"\n\n}\n</code></pre></p> <p>Next you have to add the Ktorfit KSP Plugin to the common target and every compilation target, where you want to use Ktorfit.</p> <pre><code>val ktorfitVersion = \"LATEST_KTORFIT_VERSION\"\n\ndependencies {\nadd(\"kspCommonMainMetadata\", \"de.jensklingenberg.ktorfit:ktorfit-ksp:$ktorfitVersion\")\nadd(\"ksp[NAMEOFPLATFORM]\",\"de.jensklingenberg.ktorfit:ktorfit-ksp:$ktorfitVersion\")\n...\n}\n</code></pre> <p>[NAMEOFPLATFORM] is the name of the compilation target. When you want to use it for the Android module it\u2019s kspAndroid, for Js it\u2019s kspJs, etc. Look here for more information https://kotlinlang.org/docs/ksp-multiplatform.html</p>"},{"location":"#ktorfit-lib","title":"Ktorfit-lib","text":"<p>Add the Ktorfit-lib to your common module. <pre><code>val ktorfitVersion = \"LATEST_KTORFIT_VERSION\"\n\nsourceSets {\nval commonMain by getting{\ndependencies{\nimplementation(\"de.jensklingenberg.ktorfit:ktorfit-lib:$ktorfitVersion\")\n}\n}\n</code></pre></p>"},{"location":"#ktor","title":"Ktor","text":"<p>Ktorfit is based on Ktor Clients 2.2.2. You don\u2019t need to add an extra dependency for the default clients.  When you want to use Ktor plugins for things like serialization, you need to add the dependencies and they need to be compatible with 2.0.1</p>"},{"location":"#contributions","title":"Contributions","text":"<p>When you find unexpected behaviour please write an issue</p>"},{"location":"architecture/","title":"How Ktorfit works under the hood","text":""},{"location":"architecture/#ksp-plugin","title":"KSP-Plugin","text":"<p>This will generate the code for the implementation of the interfaces</p>"},{"location":"architecture/#compiler-plugin","title":"Compiler plugin","text":"<p>This transforms the create() function from the Ktorfit lib</p>"},{"location":"architecture/#ktorfit-lib","title":"Ktorfit lib","text":"<p>A wrapper around Ktor to simplify code generation</p>"},{"location":"architecture/#example","title":"Example","text":"<p><pre><code>package com.example\n\nimport com.example.model.People\nimport de.jensklingenberg.ktorfit.http.GET\n\ninterface ExampleApi  {\n@GET(\"/test\")\nsuspend fun exampleGet(): People\n}\n</code></pre> Let`s say we have a interface like this.</p> <p>At compile time Ktorfit/KSP checks for all functions that are annotated with Ktorfit annotations like @GET.</p> <p>Then it looks at the parent interfaces of that functions and generates, the source code of a Kotlin class that implements the interface. The classes are named like the interfaces but with an underscore at the beginning and \u201cImpl\u201d at the end, and they have the same package as the interfaces. In this case a class named _ExampleApiImpl will be generated. The class will also implement KtorfitService. The setClient() function will be used to add the http client at runtime.</p> <pre><code>@OptIn(InternalKtorfitApi::class)\npublic class _ExampleApiImpl : ExampleApi, KtorfitService {\nprivate lateinit var client: KtorfitClient\n\npublic override suspend fun exampleGet(): People {\nval requestData = RequestData(method=\"GET\",\nrelativeUrl=\"/test\",\nreturnTypeData=TypeData(\"com.example.model.People\"))\n\nreturn client.suspendRequest&lt;People, People&gt;(requestData)!!\n}\n\npublic override fun setClient(client: KtorfitClient): Unit {\nthis.client = client\n}\n}\n\n@OptIn(InternalKtorfitApi::class)\npublic fun Ktorfit.createExampleApi(): ExampleApi = _ExampleApiImpl().also{\nit.setClient(KtorfitClient(this)) }\n</code></pre> <p>The next part is the compiler plugin which is added by the gradle plugin. It looks for the every usage of the create function from the Ktorfit-lib and adds an object of the  wanted implementation class as an argument. Because of the naming convention of the generated classes we can deduce the name of the class from the name of type parameter.</p> <pre><code>val api = jvmKtorfit.create&lt;ExampleApi&gt;()\n</code></pre> <p>will be transformed to: </p> <pre><code>val api = jvmKtorfit.create&lt;ExampleApi&gt;(_ExampleApiImpl())\n</code></pre> <p>When the create() function is used, the object is cast to a KtorfitService and the client will be added. Then it is cast to requested type &lt; T &gt;</p> <pre><code>fun &lt;T&gt; create(ktorfitService: KtorfitService = DefaultKtorfitService()): T {\nif (ktorfitService is DefaultKtorfitService) {\nthrow IllegalArgumentException(\"You need to enable the Ktorfit Gradle Plugin\")\n}\nktorfitService.setClient(KtorfitClient(this))\nreturn ktorfitService as T\n}\n</code></pre>"},{"location":"development/","title":"Development","text":""},{"location":"responseconverter/","title":"ResponseConverter","text":"<p>Let`s say you have a function that requests a list of comments</p> <pre><code>@GET(\"posts/{postId}/comments\")\nsuspend fun getCommentsByPostId(@Path(\"postId\") postId: Int): List&lt;Comment&gt;\n</code></pre> <p>But now you want to directly wrap your comment list in your data holder class e.g. \u201cMyOwnResponse\u201d</p> <pre><code>sealed class MyOwnResponse&lt;T&gt; {\ndata class Success&lt;T&gt;(val data: T) : Response&lt;T&gt;()\nclass Error(val ex:Throwable) : Response&lt;Nothing&gt;()\n\ncompanion object {\nfun &lt;T&gt; success(data: T) = Success(data)\nfun error(ex: Throwable) = Error(ex)\n}\n}\n</code></pre> <p>To enable that, you have to implement a ResponseConverter. This class will be used to wrap the Ktor response inside your wrapper class.</p> <pre><code>class MyOwnResponseConverter : ResponseConverter {\n\noverride suspend fun &lt;RequestType&gt; wrapResponse(\ntypeData: TypeData,\nrequestFunction: suspend () -&gt; Pair&lt;TypeInfo, HttpResponse&gt;,\nktorfit: Ktorfit\n): Any {\nreturn try {\nval (info, response) = requestFunction()\nMyOwnResponse.success&lt;Any&gt;(response.body(info))\n} catch (ex: Throwable) {\nMyOwnResponse.error(ex)\n}\n}\n\noverride fun supportedType(typeData: TypeData, isSuspend: Boolean): Boolean {\nreturn typeData.qualifiedName == \"com.example.model.MyOwnResponse\"\n}\n}\n</code></pre> <p>You can then add the ResponseConverter on your Ktorfit object.</p> <pre><code>ktorfit.responseConverter(MyOwnResponseConverter())\n</code></pre> <p>Now add MyOwnResponse to your function <pre><code>@GET(\"posts/{postId}/comments\")\nsuspend fun getCommentsByPostId(@Path(\"postId\") postId: Int): MyOwnResponse&lt;List&lt;Comment&gt;&gt;\n</code></pre></p>"},{"location":"suspendresponseconverter/","title":"SuspendResponseConverter","text":"<p>Because Ktor relies on Coroutines by default your functions need to have the suspend modifier.</p> <p>To change this, you need to use a SuspendResponseConverter, you add your own or use Flow or Call</p> <p>You can add RequestConverter on your Ktorfit object.</p> <pre><code>ktorfit.responseConverter(FlowResponseConverter())\n</code></pre>"},{"location":"suspendresponseconverter/#flow","title":"Flow","text":"<p>Ktorfit has support for Kotlin Flow. You need add the FlowResponseConverter() to your Ktorfit instance.</p> <pre><code>ktorfit.responseConverter(FlowResponseConverter())\n</code></pre> <pre><code>@GET(\"comments\")\nfun getCommentsById(@Query(\"postId\") postId: String): Flow&lt;List&lt;Comment&gt;&gt;\n</code></pre> <p>Then you can drop the suspend modifier and wrap your return type with Flow&lt;&gt;</p>"},{"location":"suspendresponseconverter/#call","title":"Call","text":"<p><pre><code>ktorfit.responseConverter(CallResponseConverter())\n</code></pre> <pre><code>@GET(\"people/{id}/\")\nfun getPersonById(@Path(\"id\") peopleId: Int): Call&lt;People&gt;\n</code></pre></p> <pre><code>exampleApi.getPersonById(3).onExecute(object : Callback&lt;People&gt;{\noverride fun onResponse(call: People, response: HttpResponse) {\n//Do something with Response\n}\n\noverride fun onError(exception: Exception) {\n//Do something with exception\n}\n})\n</code></pre> <p>You can use Call to receive the response in a Callback."},{"location":"suspendresponseconverter/#your-own","title":"Your own","text":"<p>You can also add your own Converter. You just need to implement RequestConverter. Inside the converter you need to handle the conversion from suspend to your async code.</p> <pre><code>class MyOwnResponseConverter : SuspendResponseConverter {\n...\n</code></pre>"}]}